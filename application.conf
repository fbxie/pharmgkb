deepdive {
  
  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://localhost/deepdive_titles"
    user: "czhang"
    password: "bB19871121"
  }

  calibration: {
    holdout_fraction: 0.5
  }

  schema.variables:{
    mentions.is_correct: Boolean
    relations.is_correct: Boolean
  }

  extraction.extractors: {

    load_docids:{
        output_relation: "docids"
        input: "SELECT 0"
        udf: "../pharmgkb/py/load_docids.py"
    }

    load_docs:{
        output_relation: "documents"
        input: "SELECT * FROM docids"
        udf: "../pharmgkb/py/load_docs.py"
        output_batch_size: 100
        parallelism: 8
        dependencies: ["load_docids"]
    }

    load_sents:{
        output_relation: "sentences"
        input: "SELECT * from documents"
        udf: "../pharmgkb/py/load_sents.py"
        parallelism: 8
        dependencies: ["load_docs"]
    }

    load_gene_mentions:{
        output_relation: "mentions"
        input: "SELECT * from documents"
        udf: "../pharmgkb/py/load_gene_mentions.py"
        parallelism: 8
        dependencies: ["load_docs"]
    }

    load_drug_mentions:{
        output_relation: "mentions"
        input: "SELECT * from documents"
        udf: "../pharmgkb/py/load_drug_mentions.py"
        parallelism: 8
        dependencies: ["load_docs"]
    }

    consistency_of_negative_example:{
        output_relation: "mentions"
        input: "update mentions t0 SET is_correct=False FROM  mentions t1 WHERE t0.repr=t1.repr AND t0.docid=t1.docid AND t1.is_correct=False AND t0.is_correct IS NULL;"
        udf: "cat"
        parallelism: 8
        dependencies: ["load_drug_mentions", "load_gene_mentions"]
    }

    load_relations:{
        output_relation: "relations"
        input: "SELECT t0.object as m1, t1.object as m2, t2.sentence from mentions t0, mentions t1, sentences t2 WHERE t0.sentid = t1.sentid AND t0.sentid = t2.sentid AND t0.type='DRUG' and t1.type='GENE';"
        udf: "../pharmgkb/py/load_relations.py"
        parallelism: 8
        dependencies: ["consistency_of_negative_example"]
    }

    load_relations:{
        output_relation: "relations"
        input: "SELECT t0.object as m1, t1.object as m2, t2.sentence from mentions t0, mentions t1, sentences t2 WHERE t0.sentid = t1.sentid AND t0.sentid = t2.sentid AND t0.type='DRUG' and t1.type='GENE';"
        udf: "../pharmgkb/py/load_relations.py"
        parallelism: 8
        dependencies: ["consistency_of_negative_example"]
    }

    load_negative_relations:{
        output_relation: "relations"
        input: "SELECT t0.object as m1, t1.object as m2, t2.sentence from mentions t0, mentions t1, sentences t2 WHERE t0.sentid = t1.sentid AND t0.sentid = t2.sentid AND t0.type<>'DRUG' and t1.type<>'GENE' LIMIT 10000;"
        udf: "../pharmgkb/py/load_negative_relations.py"
        parallelism: 8
        dependencies: ["consistency_of_negative_example"]
    }

  }

  inference.factors: {

    mention_factors_single.input_query: "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", unnest(t0.features) as \"t0.feature\" from mentions t0;"
    mention_factors_single.function: "mentions.t0.is_correct = Imply()"
    mention_factors_single.weight: "?(.t0.feature)"

    mention_factors_bias.input_query: "select * from mentions t0"
    mention_factors_bias.function: "mentions.is_correct = Imply()"
    mention_factors_bias.weight: "?(mentions.type)"

    relation_factors_single.input_query: "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", unnest(t0.features) as \"t0.feature\" from relations t0;"
    relation_factors_single.function: "relations.t0.is_correct = Imply()"
    relation_factors_single.weight: "?(.t0.feature)"

    relation_factors_bias.input_query: "select * from relations t0"
    relation_factors_bias.function: "relations.is_correct = Imply()"
    relation_factors_bias.weight: "?(relations.type)"

  }

  sampler.sampler_args: "-l 100 -s 1 -i 1000 -t 4 --diminish 0.95 --alpha 0.1"
  sampler.java_args = "-Xmx8g"

}













